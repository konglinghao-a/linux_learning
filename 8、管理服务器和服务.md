# 8、管理服务器和服务

## 8-1 守护进程和初始化进程服务

### 进程

- 一个运行起来的程序被称为 **进程（process）**

### 特殊的进程

- 在 Linux 中有些进程不与任何终端关联，并且无论用户的身份如何，都在后台运行
- 这些进程的父进程是 PID（进程号）为 1 的进程；PID 为 1 的进程只在系统关闭时才会被销毁
- 这些进程会在后台一直运行，并且等待我们给它们分配工作

### 守护进程/服务

- 在 Unix / Linux 的世界中，我们将这种特殊的进程称之为 daemon（守护进程）
- 守护进程也被称为 service（服务）。服务器软件大多都是以守护进程的形式运行的
- 守护进程的名字通常会在最后有一个 d，表示 daemon，例如：systemd，httpd，smdb，等

### Linux 操作系统的开机过程

BIOS 启动 —> BootLoader 启动 —> 加载内核系统 —> 内核进行初始化 —> 启动初始化进程 —> 初始化工作 

### 新旧初始化进程服务

- centos 7 以前，用 System V 来提供初始化进程服务
- centos 7 之后，用 **systemd**（它的 PID 是1，是个大佬） 来提供初始化进程服务

| systemd 命令                             | System V 命令        | 作用                               |
| ---------------------------------------- | -------------------- | ---------------------------------- |
| systemctl start toto                     | service toto start   | 启动服务                           |
| systemctl stop toto                      | service toto stop    | 停止服务                           |
| systemctl restart toto                   | service toto restart | 重启服务                           |
| systemctl status toto                    | service toto status  | 查看服务状态                       |
| systemctl reload toto                    | service toto reload  | 重载配置文件（不停止服务）         |
| systemctl enable toto                    | chkconfig toto on    | 开机自动启动服务                   |
| systemctl disable toto                   | chkconfig toto off   | 开机不自动启动服务                 |
| systemctl is-enabled toto                | chkconfig toto       | 查看服务是否开机自动启动           |
| systemctl list-unit-files --type=service | chkconfig --list     | 查看各个级别下服务的启动和禁用情况 |

## 8-2 用 systemd 来管理系统服务

- systemd 是几乎所有最新的 Linux 发行版采用的初始化系统
- systemd 的 PID（进程号）是1
- 其他进程都是它的子进程
- systemd 并不是一个命令，它包含了一组命令
- systemd 是基于事件的
- systemd 可以使进程并行启动（而 System V 使串行启动进程的）
- systemd 甚至可以重新启动因错误而停止的进程，管理任务的计划，系统日志，外设等

### 管理进程的启动和停止

- systemd 提供了 systemctl 命令，这使得我们可以管理 unit（单元），对于 systemd 来说，unit 泛指它可以操作的任何对象
- unit 可以有不同的类型：服务，挂载，外设等等
- 守护进程属于 service 类型

下面以 Samba （一个服务）来举例：

- 安装 Samba：sudo yum -y install samba
- 启动 Samba：systemctl start smb（samba 的守护进程是 smb）
- 请示 Samba：systemctl stop smb

### 使用 target

- System V 使用 Run Level（运行级别）来管理不同的进程组
- systemd 用 target 来替换了 System V 的运行级别
- target 简单来说就是多个 unit 构成的一个组

| systemd 的 target 名称 | System V 运行级别 | 作用               |
| ---------------------- | ----------------- | ------------------ |
| poweroff.target        | 0                 | 关机               |
| rescue.target          | 1                 | 单用户模式         |
| multi-user.target      | 2                 | 等同于级别3        |
| multi-user.target      | 3                 | 多用户的命令行界面 |
| multi-user.target      | 4                 | 等同于级别3        |
| graphical.target       | 5                 | 多用户的图形界面   |
| reboot.target          | 6                 | 重启               |
| emergency.target       | emergency         | 紧急 Shell         |

- 列出所有的 unit 组：**systemctl list-units --type=target --all**
- systemd 可以存在多个活动的 target，例如 swap.target，对应于可以被激活或不能被激活的系统功能
- 获取默认的 target：**systemctl get-default**，得到的结果是 **multi-user.target**
- 切换target：**systemctl isolate rescue.target**

### 使用 journalctl 命令来管理日志

- 默认地，journalctl 按时间顺序显示由 systemd 管理的所有日志

### 使用 systemd-analyze 命令查看启动耗时

- **systemd-analyze -blame**：可以看到每个 unit 的耗时
- 对于某些很耗时而你确定可以不开机启动的，你可以取消它的开机启动：**systemctl disable xxx.service**
- **systemctl mask xxx.service**：相当于强硬版的 disable，因为对某些服务 disable 可能还不好使
- mask 需要慎用，因为它会组织所有激活这个 unit 的行为，包括启用和手动激活。（如果你一不小心用了 mask，那么可以用 unmask 来取消）

## 8-3 安装 apache 服务程序

- 安装 Apache：**sudo yum install httpd**
  - 为啥叫 httpd？因为 centos 等 Red Hat 一族中 Apache 程序就叫这个。

### apache 服务的基本操作

- 启动 apache 服务：**sudo systemctl start httpd**
- 停止 apache 服务：**sudo systemctl stop httpd**
- 重启 apache 服务：**sudo systemctl restart httpd**
- 重新加载 apache 服务的配置文件：**sudo systemctl reload httpd**
- 查看 apache 服务的状态：**sudo systemctl reload httpd**
- 设置开机自动启动 apache 服务：**sudo systemctl enable httpd**
- 设置开机不启动 apache 服务：**sudo systemctl disable httpd**
- 查看 apache 服务是否开机启动：**sudo systemctl is-enable httpd**

- 开启了 apache 之后就可以在自己的本机输入 192.168.1.101 就可以访问；这时候可能访问不了，因为有防火墙挡住了；可以运行命令 **firewall-cmd --list-ports** 来查看开启的端口；这个时候我们可以让**防火墙开启一波 80 端口**：
- **firewall-cmd --zone=public --add-port=80/tcp --permanent**：开放80端口
- **firewall-cmd --zone=public --remove-port=80/tcp --permanent**：关闭80端口
- 可以重载配置防火墙策略：**firewall-cmd --reload**
- 查看开放的端口：**firewall-cmd --list-ports**
- 查看这个端口：**firewall-cmd --zone-public --query-port=80/tcp**

## 8-4 配置 apache 服务器

配置这些服务，本质上就是配置这些服务的配置文件

apache  配置文件的位置

| 配置文件的名称 | 位置                       |
| -------------- | -------------------------- |
| 服务目录       | /etc/httpd                 |
| 主配置文件     | /etc/httpd/conf/httpd.conf |
| 网站数据目录   | /var/www/html              |
| 访问日志       | /var/log/httpd/access_log  |
| 错误日志       | /var/log/httpd/error_log   |

### httpd 主配置文件的三种信息类型

- 注释（以 # 开头）
- 全局配置（如：Listen 80）
- 区域配置（如：

```shell
<Directory />
	AllowOverride none
	Require all denied
</Directory>
```

### 配置 httpd 服务的常用参数

| 参数           | 含义                   |
| -------------- | ---------------------- |
| ServerRoot     | 服务目录               |
| Listen         | 监听的 IP 地址与端口号 |
| User           | 运行服务的用户         |
| Group          | 运行服务的群组         |
| ServerAdmin    | 管理员邮箱             |
| DocumentRoot   | 网站数据目录           |
| Directory      | 网站数据目录的权限     |
| DirectoryIndex | 默认的索引页页面       |
| ErrorLog       | 错误日志文件           |
| CustomLog      | 访问日志文件           |

### 修改网站数据目录

我们可以在 `/var/www/html` 中自定义一个网页来替换掉默认的网页：

- **echo "Hello apache, my name is konglinghao" > /var/www/html/index.html**

我们可以修改 apache 的主配置文件，让网页数据目录变成：/home/web：

```shell
mkdir /home/web
echo "New Web Directory" > /home/web/index.html

# 打开主配置文件
vim /etc/httpd/conf/httpd.conf
```

`/etc/httpd/conf/httpd.conf`

```shell
# 修改 DocumentRoot 
DocumentRoot "/home/web"

# 然后需要修改一下配置权限的地方
<Directory "/home/web">
	AllowOverride None
	# Allow open access:
	Require all granted
</Directory>
```

改完以后运行：**systemctl reload httpd** 重载一波；

但是会有一个问题：现在访问 192.168.1.101 的时候还是显示 apache 的默认页面，这是咋回事呢？这是因为 **SELinux** 这个安全子系统在起作用，是它在阻止我们去访问。

### SELinux 子系统

- SELinux 是 Security-Enhanced Linux 的缩写；它是美国国家安全局在 Linux 开源社区帮助下开发的 MAC 的安全子系统
- MAC 是 Mandatory Access Control 的缩写，表示 “强制访问控制”，指一种由操作系统约束的访问控制

**SELinux 的 “双重保险”**

| 模式                           | 含义                     |
| ------------------------------ | ------------------------ |
| 域限制（Domain Limitation）    | 对服务程序的功能进行限制 |
| 安全上下文（Security Context） | 对文件资源的访问限制     |

### 防火墙和 SELinux 的区别

- 防火墙就像 “防盗门”，用于抵御外部的危险
- SELinux 就像 "保险柜"，用于保护内部的资源

### SELinux 的三种配置模式

| 配置模式   | 含义                                         |
| ---------- | -------------------------------------------- |
| enforcing  | 强制启用安全策略模式，将拦截服务的不合法请求 |
| permissive | 遇到服务越权访问时，只发出警告而不强制拦截   |
| disabled   | 对于越权的行为不警告也不拦截                 |

- 可以用 **sestatus** 来看 SELinux 的状态
- 可以用 **getenforce** 来看 SELinux 当前的模式
- 可以用 **setenforce 0** 来禁用 SELinux（也就是变成了 permissive，这是暂时的，重启时会失效）
- 可以用 **setenforce 1** 来启用 SELinux（也就是变成了 enforcing）
- 为什么 SELinux 会禁止我们去显示出正确的网页呢（就是之前把网站数据目录改成 /home/web）？那是因为 httpd 是允许用户访问网站内容，因此 SELinux 会暂时放行用户对网页的请求操作，但是之前对其配置做了修改；我们知道 home 目录是存放普通用户的数据的，但是现在 httpd 提供的网站服务却想要去获取普通用户家目录中的数据，这就违反了 SELinux 的监管原则。
- 我们可以看看 `/var/www/html` 和 `/home/web` 的区别：（ls 的 -d 参数是让其只列出**目录本身**；-Z 参数会显示安全的上下文：从左到右依次是 mode，user，group，security context and file name；安全上下文是由冒号（:）分隔开的几个组，从左到右：用户段，角色段，类型段，其他信息）

```shell
ls -Zd /var/www/html
# 打印的内容：
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html

ls -Zd /home/web
#打印的内容
drwxr-xr-x. root root unconfined_u:object_r:home_root_t:s0 /home/web

# 由上可以知道它们的安全上下文是不同的
# 我们需要把下面的安全上下文修改成跟上面的一样，这样才能让页面正确显示
# 可以用 semanage 命令来修改
```

### semanage 命令

- 是 SELinux manage 的缩写，表示 “管理 SELinux”，用于管理 SELinux 的策略
- 命令格式：semanage [选项] [文件]
- 如果系统中没有 semanager 命令，可以这样做：
  - **yum provides semanage**：可以找到哪些包提供了这个命令
  - **yum install policycoreutils-python**：通过上面那条语句可以找到这个包，所以安装

**semanage 的常用参数**

| 参数 | 功能                                               |
| ---- | -------------------------------------------------- |
| -l   | 查询                                               |
| -a   | 添加                                               |
| -m   | 修改                                               |
| -d   | 删除                                               |
| -t   | 指定类型（我们就把上面类型段的信息赋值给这个参数） |

- 然后我们就把 家目录里面的那个文件添加一个安全上下文：
  - semanage fcontext -a -t **httpd_sys_content_t** /home/web
  - semanage fcontext -a -t **httpd_sys_content_t** /home/web/*：这个文件下的文件也要设置一波
  - restorecon -Rv /home/web：递归冗余操作重新加载，这样就生效了

## 8-5 DHCP 动态分配 IP 及静态分配 IP

### DHCP：动态主机配置协议

- Dynamic Host Configuration Protocol，表示**动态主机配置协议**，是一种基于 UDP 协议且仅限于在局域网内部使用的网络协议。
- 主要用于局域网环境或者存在较多办公设备的局域网环境中
- 主要是为局域网内部的设备或网络供应商**自动分配 IP 地址**等参数
- 可以自动管理主机的 IP 地址、子网掩码、网关、DNS地址，等参数

### 网卡配置文件的常见参数

路径：`/etc/sysconfig/network-scripts/ifcfg-enp0s3`

| 参数      | 功能                                      |
| --------- | ----------------------------------------- |
| TYPE      | 设备类型                                  |
| BOOTPROTO | 地址分配模式（可以设置为 DHCP 或 STATIC） |
| NAME      | 网卡名称                                  |
| ONBOOT    | 网卡是否启动                              |
| IPADDR    | IP 地址                                   |
| NETMASK   | 子网掩码                                  |

`/etc/sysconfig/network-scripts/ifcfg-enp0s3`

```shell
# 现在想要修改成静态的 ip ，不要每次都随机分配
BOOTPROTO=static
IPADDR=192.168.0.106
NETMASK=255.255.255.0
PREFIX=24 # 和掩码的意思差不多
# 为了能上网还得加下面几句（如果是 DHCP 的话，不需要下面这两句）
GATEWAY=192.168.1.1 # 网关
DNS1=192.160.1.1 # 域名服务器
```

### nmtui：控制 Network Manager 的文本用户界面

- Network Manager Text User Interface 的缩写，表示 “网络管理器的文本用户界面”，以文字形式的用户界面来控制 Network Manager（网络管理器）
- 输入 numtui 就能进入了，这是改变 DHCP 的另一种方式。

## 8-6 apache 的虚拟主机功能

